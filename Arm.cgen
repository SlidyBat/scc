arch Arm 32

#define COND_EQ 0
#define COND_NE 1
#define COND_CS 2
#define COND_CC 3
#define COND_MI 4
#define COND_PL 5
#define COND_VS 6
#define COND_VC 7
#define COND_HI 8
#define COND_LS 9
#define COND_GE 10
#define COND_LT 11
#define COND_GT 12
#define COND_LE 13
#define COND_AL 14
#define UNCONDITIONAL 15

#define REG_FP 11
#define REG_SP 13
#define REG_LR 14
#define REG_PC 15

registerclass default IREG(8,16,32)
registerclass INTEGER_RETURN_VALUE(8,16,32) fixed { 0 } : IREG
registerclass INTEGER_RETURN_VALUE_HIGH(32) fixed { 1 } : IREG
registerclass SYSCALL_RETURN(8,16,32) fixed { 0 } : IREG
registerclass SYSCALL_RETURN_HIGH(32) fixed { 1 } : IREG
largeregisterclass IREG64(64) IREG IREG
largeregisterclass INTEGER_RETURN_VALUE_64(64) INTEGER_RETURN_VALUE INTEGER_RETURN_VALUE_HIGH
largeregisterclass SYSCALL_RETURN_64(64) SYSCALL_RETURN SYSCALL_RETURN_HIGH
tempregisterclass IRESULT(8,16,32) IREG

registerclass INTEGER_PARAM_0(8,16,32) fixed { 0 } : IREG
registerclass INTEGER_PARAM_1(8,16,32) fixed { 1 } : IREG
registerclass INTEGER_PARAM_2(8,16,32) fixed { 2 } : IREG
registerclass INTEGER_PARAM_3(8,16,32) fixed { 3 } : IREG

registerclass SYSCALL_PARAM_0(8,16,32) fixed { 0 } : IREG
registerclass SYSCALL_PARAM_1(8,16,32) fixed { 1 } : IREG
registerclass SYSCALL_PARAM_2(8,16,32) fixed { 2 } : IREG
registerclass SYSCALL_PARAM_3(8,16,32) fixed { 3 } : IREG
registerclass SYSCALL_PARAM_4(8,16,32) fixed { 4 } : IREG
registerclass SYSCALL_PARAM_5(8,16,32) fixed { 5 } : IREG
registerclass SYSCALL_PARAM_6(8,16,32) fixed { 6 } : IREG
registerclass SYSCALL_NUM(32) fixed { 7 } : IREG

immediateclass IMM16  { return (value >= 0) && (value < 0x10000); }
immediateclass IMM8  { return (value >= 0) && (value < 0x100); }
immediateclass IMM8NEG  { return (value > -0x100) && (value < 0); }
immediateclass IMM8NOT  { return (value >= -0x100) && (value < 0); }
immediateclass IMM12  { return (value >= 0) && (value < 0x1000); }
immediateclass IMM12NEG  { return (value > -0x1000) && (value < 0); }
immediateclass IMM12M4  { return (value >= 0) && (value < 0xffc); }
immediateclass IMM12M4NEG  { return (value > -0x1000) && (value <= -4); }

callersaved { 0, 1, 2, 3, 12 }
calleesaved { 4, 5, 6, 7, 8, 9, 10 }

special SYMREG_SP { SYMREG_NATIVE_REG(REG_SP) }
special SYMREG_BP { SYMREG_NATIVE_REG(REG_FP) }
special SYMREG_LR { SYMREG_NATIVE_REG(REG_LR) }
special SYMREG_IP { SYMREG_NATIVE_REG(REG_PC) }

encoding DATA_REG { cond=COND_AL:4, 0:3, op1:4, s:1, rn:4, rd:4, i=0:5, type=0:2, 0:1, rm:4 }
encoding DATA_SHIFT_REG { cond=COND_AL:4, 0:3, op1:4, s:1, rn:4, rd:4, rs=0:4, 0:1, type=0:2, 1:1, rm:4 }
encoding DATA_IMM { cond=COND_AL:4, 1:3, op1:4, s:1, rn:4, rd:4, rot=0:4, i:8 }
encoding MOV16 { cond=COND_AL:4, 1:3, op1:5, hi:4, rd:4, lo:12 }
encoding MUL { cond=COND_AL:4, 0:4, op:3, s:1, rd:4, ra:4, rm:4, 9:4, rn:4 }
encoding SATURATE { cond=COND_AL:4, 2:5, op:2, 0:1, rn:4, rd:4, rs:4, 5:4, rm:4 }
encoding EXTRA_LOAD { cond=COND_AL:4, 0:3, op1:5, rn:4, rt:4, hi:4, 1:1, op2:2, 1:1, rm:4 }
encoding LOAD_REG { cond=COND_AL:4, 3:3, op1:5, rn:4, rt:4, i=0:5, type=0:2, 0:1, rm:4 }
encoding LOAD_IMM { cond=COND_AL:4, 2:3, op1:5, rn:4, rt:4, i:12 }
encoding MISC { cond=COND_AL:4, 2:5, op:2, 0:1, op1:4, rd:4, rs:4, op2:4, rm:4 }
encoding REV { cond=COND_AL:4, 0x6bf:12, rd:4, 0xf:4, op2:3, 1:1, rm:4 }
encoding LOAD_MULTIPLE { cond=COND_AL:4, 2:2, op:6, rn:4, i:16 }
encoding BRANCH { cond=COND_AL:4, 2:2, op:2, i:24 }
encoding SVC { cond=COND_AL:4, 0xf:4, i:24 }
encoding PACK { cond=COND_AL:4, op:8, 0xf:4, rd:4, rot:2, 0:2, 7:4, rm:4 }
encoding COPROC { cond=COND_AL:4, 0xe:4, opc1:3, dir:1, crn:4, rt:4, coproc:4, opc2:3, 1:1, crm:4 }

instr function int64_t RelativeAddRead32(OutputBlock* out, Relocation& reloc)
{
	size_t start = reloc.instruction;
	uint32_t instrA = out->ReadOffsetUInt32(start);
	uint32_t instrB = out->ReadOffsetUInt32(start + 4);
	uint32_t instrC = out->ReadOffsetUInt32(start + 8);
	uint32_t op = (instrC >> 21) & 0xf;
	if (op == 4) // add
		return ((instrA >> 4) & 0xf000) | (instrA & 0xfff) | ((instrB << 12) & 0xf0000000) | ((instrB << 16) & 0xfff0000);
	else // sub
		return -(((instrA >> 4) & 0xf000) | (instrA & 0xfff) | ((instrB << 12) & 0xf0000000) | ((instrB << 16) & 0xfff0000));
}

instr function void RelativeAddWrite32(OutputBlock* out, Relocation& reloc, int64_t diff)
{
	size_t start = reloc.instruction;
	uint32_t instrA, instrB;
	uint32_t instrC = out->ReadOffsetUInt32(start + 4);
	uint32_t rd = (instrC >> 12) & 0xf;
	if (diff < 0)
	{
		instrA = @@MOV16 op1=0x10, rd=reloc.extra, hi=(-diff)>>12, lo=-diff; // movw
		instrB = @@MOV16 op1=0x14, rd=reloc.extra, hi=(-diff)>>28, lo=(-diff)>>16; // movt
		instrC = @@DATA_REG op1=2, s=0, rd=rd, rn=REG_PC, rm=reloc.extra; // sub
	}
	else
	{
		instrA = @@MOV16 op1=0x10, rd=reloc.extra, hi=diff>>12, lo=diff; // movw
		instrB = @@MOV16 op1=0x14, rd=reloc.extra, hi=diff>>28, lo=diff>>16; // movt
		instrC = @@DATA_REG op1=4, s=0, rd=rd, rn=REG_PC, rm=reloc.extra; // add
	}
	out->WriteOffsetUInt32(start, instrA);
	out->WriteOffsetUInt32(start + 4, instrB);
	out->WriteOffsetUInt32(start + 8, instrC);
}

instr function bool RelativeAddValid32(OutputBlock* out, Relocation& reloc, int64_t diff)
{
	return true;
}

instr function int64_t RelativeAddRead16(OutputBlock* out, Relocation& reloc)
{
	size_t start = reloc.instruction;
	uint32_t instrA = out->ReadOffsetUInt32(start);
	uint32_t instrB = out->ReadOffsetUInt32(start + 4);
	uint32_t op = (instrB >> 21) & 0xf;
	int32_t diff;
	if (op == 4) // add
		diff = ((instrA >> 4) & 0xf000) | (instrA & 0xfff);
	else // sub
		diff = -(((instrA >> 4) & 0xf000) | (instrA & 0xfff));
	return diff;
}

instr function void RelativeAddWrite16(OutputBlock* out, Relocation& reloc, int64_t diff)
{
	size_t start = reloc.instruction;
	uint32_t instrA;
	uint32_t instrB = out->ReadOffsetUInt32(start + 4);
	uint32_t rd = (instrB >> 12) & 0xf;
	if (diff < 0)
	{
		instrA = @@MOV16 op1=0x10, rd=reloc.extra, hi=(-diff)>>12, lo=-diff; // movw
		instrB = @@DATA_REG op1=2, s=0, rd=rd, rn=REG_PC, rm=reloc.extra; // sub
	}
	else
	{
		instrA = @@MOV16 op1=0x10, rd=reloc.extra, hi=diff>>12, lo=diff; // movw
		instrB = @@DATA_REG op1=4, s=0, rd=rd, rn=REG_PC, rm=reloc.extra; // add
	}
	out->WriteOffsetUInt32(start, instrA);
	out->WriteOffsetUInt32(start + 4, instrB);
}

instr function bool RelativeAddValid16(OutputBlock* out, Relocation& reloc, int64_t diff)
{
	return (diff > -0x10000) && (diff < 0x10000);
}

instr function void RelativeAddOverflow16(OutputBlock* out, Relocation& reloc)
{
	size_t start = reloc.instruction;
	uint32_t instrs[3];
	instrs[0] = out->ReadOffsetUInt32(start);
	instrs[1] = @@MOV16 op1=0x14, rd=reloc.extra, hi=0, lo=0; // movt
	instrs[2] = out->ReadOffsetUInt32(start + 4);

	if (out->bigEndian)
	{
		instrs[0] = BE32(instrs[0]);
		instrs[1] = BE32(instrs[1]);
		instrs[2] = BE32(instrs[2]);
	}

	out->ReplaceInstruction(start, 8, instrs, 12, 8);

	reloc.bitSize = 32;
	reloc.offset += 4;
	reloc.overflow = NULL;
	reloc.read = RelativeAddRead32;
	reloc.write = RelativeAddWrite32;
	reloc.valid = RelativeAddValid32;
}

instr function int64_t RelativeAddRead8(OutputBlock* out, Relocation& reloc)
{
	size_t start = reloc.instruction;
	uint32_t instr = out->ReadOffsetUInt32(start);
	uint32_t op = (instr >> 21) & 0xf;
	int32_t diff;
	if (op == 4) // add
		diff = instr & 0xff;
	else // sub
		diff = -(instr & 0xff);
	return diff;
}

instr function void RelativeAddWrite8(OutputBlock* out, Relocation& reloc, int64_t diff)
{
	size_t start = reloc.instruction;
	uint32_t instr = out->ReadOffsetUInt32(start);
	uint32_t rd = (instr >> 12) & 0xf;
	if (diff < 0)
		instr = @@DATA_IMM op1=2, s=0, rd=rd, rn=REG_PC, i=-diff; // sub
	else
		instr = @@DATA_IMM op1=4, s=0, rd=rd, rn=REG_PC, i=diff; // add
	out->WriteOffsetUInt32(start, instr);
}

instr function bool RelativeAddValid8(OutputBlock* out, Relocation& reloc, int64_t diff)
{
	return (diff > -0x100) && (diff < 0x100);
}

instr function void RelativeAddOverflow8(OutputBlock* out, Relocation& reloc)
{
	size_t start = reloc.instruction;
	uint32_t oldInstr = out->ReadOffsetUInt32(start);
	uint32_t rd = (oldInstr >> 12) & 0xf;
	uint32_t op = (oldInstr >> 21) & 0xf;
	uint32_t diff = oldInstr & 0xfff;

	uint32_t instrs[2];
	instrs[0] = @@MOV16 op1=0x10, rd=reloc.extra, hi=diff>>12, lo=diff; // movw
	instrs[1] = @@DATA_REG op1=op, s=0, rd=rd, rn=REG_PC, rm=reloc.extra; // add

	if (out->bigEndian)
	{
		instrs[0] = BE32(instrs[0]);
		instrs[1] = BE32(instrs[1]);
	}

	out->ReplaceInstruction(start, 4, instrs, 8, 4);

	reloc.bitSize = 16;
	reloc.overflow = RelativeAddOverflow16;
	reloc.read = RelativeAddRead16;
	reloc.write = RelativeAddWrite16;
	reloc.valid = RelativeAddValid16;
}

#define DATA_INSTR(name, opcode) \
instr name  name rd:REG(w), rn:REG(r), rm:REG(r)  { @DATA_REG op1=opcode, s=0; } \
instr name##_lsl_imm  name rd:REG(w), rn:REG(r), rm:REG(r) lsl i:IMM  { @DATA_REG op1=opcode, s=0, type=0; } \
instr name##_lsr_imm  name rd:REG(w), rn:REG(r), rm:REG(r) lsr i:IMM  { @DATA_REG op1=opcode, s=0, type=1; } \
instr name##_asr_imm  name rd:REG(w), rn:REG(r), rm:REG(r) asr i:IMM  { @DATA_REG op1=opcode, s=0, type=2; } \
instr name##_lsl_reg  name rd:REG(w), rn:REG(r), rm:REG(r) lsl rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=0, type=0; } \
instr name##_lsr_reg  name rd:REG(w), rn:REG(r), rm:REG(r) lsr rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=0, type=1; } \
instr name##_asr_reg  name rd:REG(w), rn:REG(r), rm:REG(r) asr rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=0, type=2; } \
instr name##_imm  name rd:REG(w), rn:REG(r), i:IMM  { @DATA_IMM op1=opcode, s=0; } \
instr(writeflags) name##s  name##s rd:REG(w), rn:REG(r), rm:REG(r)  { @DATA_REG op1=opcode, s=1; } \
instr(writeflags) name##s_lsl_imm  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsl i:IMM  { @DATA_REG op1=opcode, s=1, type=0; } \
instr(writeflags) name##s_lsr_imm  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsr i:IMM  { @DATA_REG op1=opcode, s=1, type=1; } \
instr(writeflags) name##s_asr_imm  name##s rd:REG(w), rn:REG(r), rm:REG(r) asr i:IMM  { @DATA_REG op1=opcode, s=1, type=2; } \
instr(writeflags) name##s_lsl_reg  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsl rs:REG(r) \
	{ @DATA_SHIFT_REG op1=opcode, s=1, type=0; } \
instr(writeflags) name##s_lsr_reg  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsr rs:REG(r) \
	{ @DATA_SHIFT_REG op1=opcode, s=1, type=1; } \
instr(writeflags) name##s_asr_reg  name##s rd:REG(w), rn:REG(r), rm:REG(r) asr rs:REG(r) \
	{ @DATA_SHIFT_REG op1=opcode, s=1, type=2; } \
instr(writeflags) name##s_imm  name##s rd:REG(w), rn:REG(r), i:IMM  { @DATA_IMM op1=opcode, s=1; }
DATA_INSTR(and, 0)
DATA_INSTR(eor, 1)
DATA_INSTR(sub, 2)
DATA_INSTR(rsb, 3)
DATA_INSTR(add, 4)
DATA_INSTR(orr, 0xc)
DATA_INSTR(bic, 0xe)

instr add_stack  add rd:REG(w), var:STACKVAR
{
	if ((%var:offset > -0x100) && (%var:offset < 0))
		@DATA_IMM op1=2, s=0, rn=%var:base, i=-%var:offset; // sub
	else if ((%var:offset < 0x100) && (%var:offset >= 0))
		@DATA_IMM op1=4, s=0, rn=%var:base, i=%var:offset; // add
	else if ((%var:offset > -0x10000) && (%var:offset < 0))
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=(-%var:offset)>>12, lo=-%var:offset; // movw
		@DATA_REG op1=2, s=0, rn=%var:base, rm=%var:temp; // sub
	}
	else if ((%var:offset < 0x10000) && (%var:offset >= 0))
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; // movw
		@DATA_REG op1=4, s=0, rn=%var:base, rm=%var:temp; // add
	}
	else
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; // movw
		@MOV16 op1=0x14, rd=%var:temp, hi=%var:offset>>28, lo=%var:offset>>16; // movt
		@DATA_REG op1=4, s=0, rn=%var:base, rm=%var:temp; // add
	}
}

instr sub_stack  add rd:REG(w), var:STACKVAR
{
	if ((%var:offset > -0x100) && (%var:offset < 0))
		@DATA_IMM op1=4, s=0, rn=%var:base, i=-%var:offset; // add
	else if ((%var:offset < 0x100) && (%var:offset >= 0))
		@DATA_IMM op1=2, s=0, rn=%var:base, i=%var:offset; // sub
	else if ((%var:offset > -0x10000) && (%var:offset < 0))
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=(-%var:offset)>>12, lo=-%var:offset; // movw
		@DATA_REG op1=4, s=0, rn=%var:base, rm=%var:temp; // add
	}
	else if ((%var:offset < 0x10000) && (%var:offset >= 0))
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; // movw
		@DATA_REG op1=2, s=0, rn=%var:base, rm=%var:temp; // sub
	}
	else
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; // movw
		@MOV16 op1=0x14, rd=%var:temp, hi=%var:offset>>28, lo=%var:offset>>16; // movt
		@DATA_REG op1=2, s=0, rn=%var:base, rm=%var:temp; // sub
	}
}

instr add_global  add rd:REG(w), var:GLOBALVAR
{
	@DATA_IMM op1=2, s=0, rn=REG_PC, i=8; // sub %rd, pc, 8

	Relocation reloc;
	reloc.type = DATA_RELOC_RELATIVE_CUSTOM_FIELD;
	reloc.instruction = out->len - 4;
	reloc.offset = out->len - 4;
	reloc.extra = %var:temp;
	reloc.dataOffset = %var:offset;
	reloc.bitSize = 8;
	reloc.overflow = RelativeAddOverflow8;
	reloc.read = RelativeAddRead8;
	reloc.write = RelativeAddWrite8;
	reloc.valid = RelativeAddValid8;
	out->relocs.push_back(reloc);
}

instr add_block add rd:REG(w), func:FUNCTION, temp:TEMP
{
	@DATA_IMM op1=2, s=0, rn=REG_PC, i=8; // sub %rd, pc, 8

	Relocation reloc;
	reloc.type = CODE_RELOC_RELATIVE_CUSTOM_FIELD;
	reloc.instruction = out->len - 4;
	reloc.offset = out->len - 4;
	reloc.extra = %temp;
	reloc.target = %func:block;
	reloc.bitSize = 8;
	reloc.overflow = RelativeAddOverflow8;
	reloc.read = RelativeAddRead8;
	reloc.write = RelativeAddWrite8;
	reloc.valid = RelativeAddValid8;
	out->relocs.push_back(reloc);
}

#define DATA_INSTR_CARRY(name, opcode) \
instr(readflags) name  name rd:REG(w), rn:REG(r), rm:REG(r)  { @DATA_REG op1=opcode, s=0; } \
instr(readflags) name##_lsl_imm  name rd:REG(w), rn:REG(r), rm:REG(r) lsl i:IMM  { @DATA_REG op1=opcode, s=0, type=0; } \
instr(readflags) name##_lsr_imm  name rd:REG(w), rn:REG(r), rm:REG(r) lsr i:IMM  { @DATA_REG op1=opcode, s=0, type=1; } \
instr(readflags) name##_asr_imm  name rd:REG(w), rn:REG(r), rm:REG(r) asr i:IMM  { @DATA_REG op1=opcode, s=0, type=2; } \
instr(readflags) name##_lsl_reg  name rd:REG(w), rn:REG(r), rm:REG(r) lsl rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=0, type=0; } \
instr(readflags) name##_lsr_reg  name rd:REG(w), rn:REG(r), rm:REG(r) lsr rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=0, type=1; } \
instr(readflags) name##_asr_reg  name rd:REG(w), rn:REG(r), rm:REG(r) asr rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=0, type=2; } \
instr(readflags) name##_imm  name rd:REG(w), rn:REG(r), i:IMM  { @DATA_IMM op1=opcode, s=0; } \
instr(readflags, writeflags) name##s  name##s rd:REG(w), rn:REG(r), rm:REG(r)  { @DATA_REG op1=opcode, s=1; } \
instr(readflags, writeflags) name##s_lsl_imm  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsl i:IMM \
	{ @DATA_REG op1=opcode, s=1, type=0; } \
instr(readflags, writeflags) name##s_lsr_imm  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsr i:IMM \
	{ @DATA_REG op1=opcode, s=1, type=1; } \
instr(readflags, writeflags) name##s_asr_imm  name##s rd:REG(w), rn:REG(r), rm:REG(r) asr i:IMM \
	{ @DATA_REG op1=opcode, s=1, type=2; } \
instr(readflags, writeflags) name##s_lsl_reg  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsl rs:REG(r) \
	{ @DATA_SHIFT_REG op1=opcode, s=1, type=0; } \
instr(readflags, writeflags) name##s_lsr_reg  name##s rd:REG(w), rn:REG(r), rm:REG(r) lsr rs:REG(r) \
	{ @DATA_SHIFT_REG op1=opcode, s=1, type=1; } \
instr(readflags, writeflags) name##s_asr_reg  name##s rd:REG(w), rn:REG(r), rm:REG(r) asr rs:REG(r) \
	{ @DATA_SHIFT_REG op1=opcode, s=1, type=2; } \
instr(readflags, writeflags) name##s_imm  name##s rd:REG(w), rn:REG(r), i:IMM  { @DATA_IMM op1=opcode, s=1; }
DATA_INSTR_CARRY(adc, 5)
DATA_INSTR_CARRY(sbc, 6)
DATA_INSTR_CARRY(rsc, 7)

#define COMPARE_INSTR(name, opcode) \
instr(writeflags) name  name rn:REG(r), rm:REG(r)  { @DATA_REG op1=opcode, s=1; } \
instr(writeflags) name##_lsl_imm  name rn:REG(r), rm:REG(r) lsl i:IMM  { @DATA_REG op1=opcode, s=1, type=0; } \
instr(writeflags) name##_lsr_imm  name rn:REG(r), rm:REG(r) lsr i:IMM  { @DATA_REG op1=opcode, s=1, type=1; } \
instr(writeflags) name##_asr_imm  name rn:REG(r), rm:REG(r) asr i:IMM  { @DATA_REG op1=opcode, s=1, type=2; } \
instr(writeflags) name##_lsl_reg  name rn:REG(r), rm:REG(r) lsl rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=1, type=0; } \
instr(writeflags) name##_lsr_reg  name rn:REG(r), rm:REG(r) lsr rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=1, type=1; } \
instr(writeflags) name##_asr_reg  name rn:REG(r), rm:REG(r) asr rs:REG(r)  { @DATA_SHIFT_REG op1=opcode, s=1, type=2; } \
instr(writeflags) name##_imm  name rn:REG(r), i:IMM  { @DATA_IMM op1=opcode, s=1; }
COMPARE_INSTR(tst, 8)
COMPARE_INSTR(teq, 9)
COMPARE_INSTR(cmp, 0xa)
COMPARE_INSTR(cmn, 0xb)

instr(copy) mov  mov rd:REG(w), rm:REG(r)  { @DATA_REG op1=0xd, s=0; } update
{
	if (%rd == %rm)
		return true;
	return false;
}

instr mov_imm  mov rd:REG(w), i:IMM  { @DATA_IMM op1=0xd, s=0; }
instr lsl_imm  lsl rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=0, type=0; }
instr lsr_imm  lsr rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=0, type=1; }
instr asr_imm  asr rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=0, type=2; }
instr(readflags) rrx  lsl rd:REG(w), rm:REG(r)  { @DATA_REG op1=0xd, s=0, type=3, i=0; }
instr ror_imm  ror rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=0, type=3; }
instr lsl  lsl rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=0, type=0; }
instr lsr  lsr rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=0, type=1; }
instr asr  asr rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=0, type=2; }
instr ror  ror rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=0, type=3; }
instr(copy, writeflags) movs  movs rd:REG(w), rm:REG(r)  { @DATA_REG op1=0xd, s=1; }
instr(writeflags) movs_imm  movs rd:REG(w), i:IMM  { @DATA_IMM op1=0xd, s=1; }
instr(writeflags) lsls_imm  lsls rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=1, type=0; }
instr(writeflags) lsrs_imm  lsrs rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=1, type=1; }
instr(writeflags) asrs_imm  asrs rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=1, type=2; }
instr(readflags, writeflags) rrxs  rrxs rd:REG(w), rm:REG(r)  { @DATA_REG op1=0xd, s=1, type=3, i=0; }
instr(writeflags) rors_imm  rors rd:REG(w), rm:REG(r), i:IMM  { @DATA_REG op1=0xd, s=1, type=3; }
instr(writeflags) lsls  lsls rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=1, type=0; }
instr(writeflags) lsrs  lsrs rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=1, type=1; }
instr(writeflags) asrs  asrs rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=1, type=2; }
instr(writeflags) rors  rors rd:REG(w), rm:REG(r), rs:REG(r)  { @DATA_SHIFT_REG op1=0xd, s=1, type=3; }

instr mvn  mvn rd:REG(w), rm:REG(r)  { @DATA_REG op1=0xf, s=0; }
instr mvn_imm  mvn rd:REG(w), i:IMM  { @DATA_IMM op1=0xf, s=0; }
instr mvn_lsl_imm  mvn rd:REG(w), rm:REG(r) lsl i:IMM  { @DATA_REG op1=0xf, s=0, type=0; }
instr mvn_lsr_imm  mvn rd:REG(w), rm:REG(r) lsr i:IMM  { @DATA_REG op1=0xf, s=0, type=1; }
instr mvn_asr_imm  mvn rd:REG(w), rm:REG(r) asr i:IMM  { @DATA_REG op1=0xf, s=0, type=2; }
instr mvn_lsl_reg  mvn rd:REG(w), rm:REG(r) lsl rs:REG(r)  { @DATA_REG op1=0xf, s=0, type=0; }
instr mvn_lsr_reg  mvn rd:REG(w), rm:REG(r) lsr rs:REG(r)  { @DATA_REG op1=0xf, s=0, type=1; }
instr mvn_asr_reg  mvn rd:REG(w), rm:REG(r) asr rs:REG(r)  { @DATA_REG op1=0xf, s=0, type=2; }
instr(writeflags) mvns  movs rd:REG(w), rm:REG(r)  { @DATA_REG op1=0xf, s=1; }
instr(writeflags) mvns_imm  movs rd:REG(w), i:IMM  { @DATA_IMM op1=0xf, s=1; }
instr(writeflags) mvns_lsl_imm  mvns rd:REG(w), rm:REG(r) lsl i:IMM  { @DATA_REG op1=0xf, s=1, type=0; }
instr(writeflags) mvns_lsr_imm  mvns rd:REG(w), rm:REG(r) lsr i:IMM  { @DATA_REG op1=0xf, s=1, type=1; }
instr(writeflags) mvns_asr_imm  mvns rd:REG(w), rm:REG(r) asr i:IMM  { @DATA_REG op1=0xf, s=1, type=2; }
instr(writeflags) mvns_lsl_reg  mvns rd:REG(w), rm:REG(r) lsl rs:REG(r)  { @DATA_REG op1=0xf, s=1, type=0; }
instr(writeflags) mvns_lsr_reg  mvns rd:REG(w), rm:REG(r) lsr rs:REG(r)  { @DATA_REG op1=0xf, s=1, type=1; }
instr(writeflags) mvns_asr_reg  mvns rd:REG(w), rm:REG(r) asr rs:REG(r)  { @DATA_REG op1=0xf, s=1, type=2; }

instr movw  movw rd:REG(w), i:IMM  { @MOV16 op1=0x10, hi=i>>12, lo=i; }
instr movt  movt rd:REG(rw), i:IMM  { @MOV16 op1=0x14, hi=i>>12, lo=i; }

instr mul  mul rd:REG(w), rn:REG(r), rm:REG(r)  { @MUL op=0, s=0; }
instr(writeflags) muls  muls rd:REG(w), rn:REG(r), rm:REG(r)  { @MUL op=0, s=1; }
instr mla  mla rd:REG(w), rn:REG(r), rm:REG(r), ra:REG(r)  { @MUL op=1, s=0; }
instr(writeflags) mlas  mlas rd:REG(w), rn:REG(r), rm:REG(r), ra:REG(r)  { @MUL op=1, s=1; }
instr umaal  umaal ra:REG(rw), rd:REG(rw), rn:REG(r), rm:REG(r)  { @MUL op=2, s=0; }
instr(writeflags) mls  mls rd:REG(w), rn:REG(r), rm:REG(r), ra:REG(r)  { @MUL op=3, s=0; }
instr umull  umull ra:REG(w), rd:REG(w), rn:REG(r), rm:REG(r)  { @MUL op=4, s=0; }
instr(writeflags) umulls  umulls ra:REG(w), rd:REG(w), rn:REG(r), rm:REG(r)  { @MUL op=4, s=1; }
instr umlal  umlal ra:REG(rw), rd:REG(rw), rn:REG(r), rm:REG(r)  { @MUL op=5, s=0; }
instr(writeflags) umlals  umlals ra:REG(rw), rd:REG(rw), rn:REG(r), rm:REG(r)  { @MUL op=5, s=1; }
instr smull  smull ra:REG(w), rd:REG(w), rn:REG(r), rm:REG(r)  { @MUL op=6, s=0; }
instr(writeflags) smulls  smulls ra:REG(w), rd:REG(w), rn:REG(r), rm:REG(r)  { @MUL op=6, s=1; }
instr smlal  smlal ra:REG(rw), rd:REG(rw), rn:REG(r), rm:REG(r)  { @MUL op=7, s=0; }
instr(writeflags) smlals  smlals ra:REG(rw), rd:REG(rw), rn:REG(r), rm:REG(r)  { @MUL op=7, s=1; }

instr(writeflags) qadd  qadd rd:REG(w), rm:REG(r), rn:REG(r)  { @SATURATE op=0; }
instr(writeflags) qsub  qsub rd:REG(w), rm:REG(r), rn:REG(r)  { @SATURATE op=1; }
instr(writeflags) qdadd  qdadd rd:REG(w), rm:REG(r), rn:REG(r)  { @SATURATE op=2; }
instr(writeflags) qdsub  qdsub rd:REG(w), rm:REG(r), rn:REG(r)  { @SATURATE op=3; }

instr sxtb  sxtb rd:REG(w), rm:REG(r), rot:IMM  { @PACK op=0x6a; }
instr sxth  sxth rd:REG(w), rm:REG(r), rot:IMM  { @PACK op=0x6b; }
instr uxtb  uxtb rd:REG(w), rm:REG(r), rot:IMM  { @PACK op=0x6e; }
instr uxth  uxth rd:REG(w), rm:REG(r), rot:IMM  { @PACK op=0x6f; }

instr(memory) strh_reg  strh rt:REG(r), [rn:REG(r) + rm:REG(r)]  { @EXTRA_LOAD op1=0x18, op2=1; }
instr(memory) strh_reg_pre  strh rt:REG(r), [rn:REG(rw) + rm:REG(r)]!  { @EXTRA_LOAD op1=0x1a, op2=1; }
instr(memory) strh_reg_post  strh rt:REG(r), [rn:REG(rw)], rm:REG(r)  { @EXTRA_LOAD op1=8, op2=1; }
instr(memory) strh_sub  strh rt:REG(r), [rn:REG(r) - rm:REG(r)]  { @EXTRA_LOAD op1=0x10, op2=1; }
instr(memory) strh_sub_pre  strh rt:REG(r), [rn:REG(rw)], -rm:REG(r)  { @EXTRA_LOAD op1=0x12, op2=1; }
instr(memory) strh_sub_post  strh rt:REG(r), [rn:REG(rw) - rm:REG(r)]!  { @EXTRA_LOAD op1=0, op2=1; }
instr(memory) strh_imm  strh rt:REG(r), [rn:REG(r) + i:IMM]  { @EXTRA_LOAD op1=0x1c, op2=1, hi=i>>4, rm=i; }
instr(memory) strh_pre_imm  strh rt:REG(r), [rn:REG(rw) + i:IMM]!  { @EXTRA_LOAD op1=0x1e, op2=1, hi=i>>4, rm=i; }
instr(memory) strh_post_imm  strh rt:REG(r), [rn:REG(rw)], i:IMM  { @EXTRA_LOAD op1=0xc, op2=1, hi=i>>4, rm=i; }
instr(memory) strh_sub_imm  strh rt:REG(r), [rn:REG(r) - i:IMM]  { @EXTRA_LOAD op1=0x14, op2=1, hi=i>>4, rm=i; }
instr(memory) strh_sub_pre_imm  strh rt:REG(r), [rn:REG(rw)], -i:IMM  { @EXTRA_LOAD op1=0x16, op2=1, hi=i>>4, rm=i; }
instr(memory) strh_sub_post_imm  strh rt:REG(r), [rn:REG(rw) - i:IMM]!  { @EXTRA_LOAD op1=4, op2=1, hi=i>>4, rm=i; }
instr(memory) strh_stack  strh rt:REG(r), [var:STACKVAR]
{
	if ((%var:offset > -0x100) && (%var:offset < 0))
		@EXTRA_LOAD op1=0x14, op2=1, rn=%var:base, hi=(-%var:offset)>>4, rm=-%var:offset; // strh
	else if ((%var:offset < 0x100) && (%var:offset >= 0))
		@EXTRA_LOAD op1=0x1c, op2=1, rn=%var:base, hi=%var:offset>>4, rm=%var:offset; // strh
	else if ((%var:offset > -0x10000) && (%var:offset < 0))
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=(-%var:offset)>>12, lo=-%var:offset; // movw
		@EXTRA_LOAD op1=0x10, op2=1, rn=%var:base, rm=%var:temp; // strh
	}
	else if ((%var:offset < 0x10000) && (%var:offset >= 0))
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; // movw
		@EXTRA_LOAD op1=0x18, op2=1, rn=%var:base, rm=%var:temp; // strh
	}
	else
	{
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; // movw
		@MOV16 op1=0x14, rd=%var:temp, hi=%var:offset>>28, lo=%var:offset>>16; // movt
		@EXTRA_LOAD op1=0x18, op2=1, rn=%var:base, rm=%var:temp; // strh
	}
}

#define LOAD_EXTRA_INSTR(name, opcode) \
instr(memory) name##_reg  name rt:REG(w), [rn:REG(r) + rm:REG(r)]  { @EXTRA_LOAD op1=0x19, op2=opcode; } \
instr(memory) name##_reg_pre  name rt:REG(w), [rn:REG(rw) + rm:REG(r)]!  { @EXTRA_LOAD op1=0x1b, op2=opcode; } \
instr(memory) name##_reg_post  name rt:REG(w), [rn:REG(rw)], rm:REG(r)  { @EXTRA_LOAD op1=9, op2=opcode; } \
instr(memory) name##_sub_reg  name rt:REG(w), [rn:REG(r) - rm:REG(r)]  { @EXTRA_LOAD op1=0x11, op2=opcode; } \
instr(memory) name##_sub_reg_pre  name rt:REG(w), [rn:REG(rw)], -rm:REG(r)  { @EXTRA_LOAD op1=0x13, op2=opcode; } \
instr(memory) name##_sub_reg_post  name rt:REG(w), [rn:REG(rw) - rm:REG(r)]!  { @EXTRA_LOAD op1=1, op2=opcode; } \
instr(memory) name##_imm  name rt:REG(w), [rn:REG(r) + i:IMM]  { @EXTRA_LOAD op1=0x1d, op2=opcode, hi=i>>4, rm=i; } \
instr(memory) name##_imm_pre  name rt:REG(w), [rn:REG(rw) + i:IMM]!  { @EXTRA_LOAD op1=0x1f, op2=opcode, hi=i>>4, rm=i; } \
instr(memory) name##_imm_post  name rt:REG(w), [rn:REG(rw)], i:IMM  { @EXTRA_LOAD op1=0xd, op2=opcode, hi=i>>4, rm=i; } \
instr(memory) name##_sub_imm  name rt:REG(w), [rn:REG(r) - i:IMM]  { @EXTRA_LOAD op1=0x15, op2=opcode, hi=i>>4, rm=i; } \
instr(memory) name##_sub_imm_pre  name rt:REG(w), [rn:REG(rw)], -i:IMM  { @EXTRA_LOAD op1=0x17, op2=opcode, hi=i>>4, rm=i; } \
instr(memory) name##_sub_imm_post  name rt:REG(w), [rn:REG(rw) - i:IMM]!  { @EXTRA_LOAD op1=5, op2=opcode, hi=i>>4, rm=i; } \
instr(memory) name##_stack  name rt:REG(w), [var:STACKVAR] \
{ \
	if ((%var:offset > -0x100) && (%var:offset < 0)) \
		@EXTRA_LOAD op1=0x15, op2=opcode, rn=%var:base, hi=(-%var:offset)>>4, rm=-%var:offset; \
	else if ((%var:offset < 0x100) && (%var:offset >= 0)) \
		@EXTRA_LOAD op1=0x1d, op2=opcode, rn=%var:base, hi=%var:offset>>4, rm=%var:offset; \
	else if ((%var:offset > -0x10000) && (%var:offset < 0)) \
	{ \
		@MOV16 op1=0x10, rd=%var:temp, hi=(-%var:offset)>>12, lo=-%var:offset; \
		@EXTRA_LOAD op1=0x11, op2=opcode, rn=%var:base, rm=%var:temp; \
	} \
	else if ((%var:offset < 0x10000) && (%var:offset >= 0)) \
	{ \
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; \
		@EXTRA_LOAD op1=0x19, op2=opcode, rn=%var:base, rm=%var:temp; \
	} \
	else \
	{ \
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; \
		@MOV16 op1=0x14, rd=%var:temp, hi=%var:offset>>28, lo=%var:offset>>16; \
		@EXTRA_LOAD op1=0x19, op2=opcode, rn=%var:base, rm=%var:temp; \
	} \
}
LOAD_EXTRA_INSTR(ldrh, 1)
LOAD_EXTRA_INSTR(ldrsb, 2)
LOAD_EXTRA_INSTR(ldrsh, 3)

#define LOAD_INSTR(name, v, opcode) \
instr(memory) name##_reg  name rt:REG(v), [rn:REG(r) + rm:REG(r)]  { @LOAD_REG op1=opcode+0x18; } \
instr(memory) name##_reg_pre  name rt:REG(v), [rn:REG(rw) + rm:REG(r)]!  { @LOAD_REG op1=opcode+0x1a; } \
instr(memory) name##_reg_post  name rt:REG(v), [rn:REG(rw)], rm:REG(r)  { @LOAD_REG op1=opcode+8; } \
instr(memory) name##_sub_reg  name rt:REG(v), [rn:REG(r) - rm:REG(r)]  { @LOAD_REG op1=opcode+0x10; } \
instr(memory) name##_sub_reg_pre  name rt:REG(v), [rn:REG(rw)], -rm:REG(r)  { @LOAD_REG op1=opcode+0x12; } \
instr(memory) name##_sub_reg_post  name rt:REG(v), [rn:REG(rw) - rm:REG(r)]!  { @LOAD_REG op1=opcode; } \
instr(memory) name##_lsl  name rt:REG(v), [rn:REG(r) + rm:REG(r) lsl i:IMM]  { @LOAD_REG op1=opcode+0x18, type=0; } \
instr(memory) name##_lsl_pre  name rt:REG(v), [rn:REG(rw) + rm:REG(r) lsl i:IMM]!  { @LOAD_REG op1=opcode+0x1a, type=0; } \
instr(memory) name##_lsl_post  name rt:REG(v), [rn:REG(rw)], rm:REG(r) lsl i:IMM  { @LOAD_REG op1=opcode+8, type=0; } \
instr(memory) name##_sub_lsl  name rt:REG(v), [rn:REG(r) - rm:REG(r) lsl i:IMM]  { @LOAD_REG op1=opcode+0x10, type=0; } \
instr(memory) name##_sub_lsl_pre  name rt:REG(v), [rn:REG(rw)], -rm:REG(r) lsl i:IMM  { @LOAD_REG op1=opcode+0x12, type=0; } \
instr(memory) name##_sub_lsl_post  name rt:REG(v), [rn:REG(rw) - rm:REG(r) lsl i:IMM]!  { @LOAD_REG op1=opcode, type=0; } \
instr(memory) name##_lsr  name rt:REG(v), [rn:REG(r) + rm:REG(r) lsr i:IMM]  { @LOAD_REG op1=opcode+0x18, type=1; } \
instr(memory) name##_lsr_pre  name rt:REG(v), [rn:REG(rw) + rm:REG(r) lsr i:IMM]!  { @LOAD_REG op1=opcode+0x1a, type=1; } \
instr(memory) name##_lsr_post  name rt:REG(v), [rn:REG(rw)], rm:REG(r) lsr i:IMM  { @LOAD_REG op1=opcode+8, type=1; } \
instr(memory) name##_sub_lsr  name rt:REG(v), [rn:REG(r) - rm:REG(r) lsr i:IMM]  { @LOAD_REG op1=opcode+0x10, type=1; } \
instr(memory) name##_sub_lsr_pre  name rt:REG(v), [rn:REG(rw)], -rm:REG(r) lsr i:IMM  { @LOAD_REG op1=opcode+0x12, type=1; } \
instr(memory) name##_sub_lsr_post  name rt:REG(v), [rn:REG(rw) - rm:REG(r) lsr i:IMM]!  { @LOAD_REG op1=opcode, type=1; } \
instr(memory) name##_asr  name rt:REG(v), [rn:REG(r) + rm:REG(r) asr i:IMM]  { @LOAD_REG op1=opcode+0x18, type=2; } \
instr(memory) name##_asr_pre  name rt:REG(v), [rn:REG(rw) + rm:REG(r) asr i:IMM]!  { @LOAD_REG op1=opcode+0x1a, type=2; } \
instr(memory) name##_asr_post  name rt:REG(v), [rn:REG(rw)], rm:REG(r) asr i:IMM  { @LOAD_REG op1=opcode+8, type=2; } \
instr(memory) name##_sub_asr  name rt:REG(v), [rn:REG(r) - rm:REG(r) asr i:IMM]  { @LOAD_REG op1=opcode+0x10, type=2; } \
instr(memory) name##_sub_asr_pre  name rt:REG(v), [rn:REG(rw)], -rm:REG(r) asr i:IMM  { @LOAD_REG op1=opcode+0x12, type=2; } \
instr(memory) name##_sub_asr_post  name rt:REG(v), [rn:REG(rw) - rm:REG(r) asr i:IMM]!  { @LOAD_REG op1=opcode, type=2; } \
instr(memory) name##_imm  name rt:REG(v), [rn:REG(r) + i:IMM]  { @LOAD_IMM op1=opcode+0x18; } \
instr(memory) name##_pre_imm  name rt:REG(v), [rn:REG(rw) + i:IMM]!  { @LOAD_IMM op1=opcode+0x1a; } \
instr(memory) name##_post_imm  name rt:REG(v), [rn:REG(rw)], i:IMM  { @LOAD_IMM op1=opcode+8; } \
instr(memory) name##_sub_imm  name rt:REG(v), [rn:REG(r) - i:IMM]  { @LOAD_IMM op1=opcode+0x10; } \
instr(memory) name##_sub_imm_pre  name rt:REG(v), [rn:REG(rw)], -i:IMM  { @LOAD_IMM op1=opcode+0x12; } \
instr(memory) name##_sub_imm_post  name rt:REG(v), [rn:REG(rw) - i:IMM]!  { @LOAD_IMM op1=opcode; } \
instr(memory) name##_stack  name rt:REG(v), [var:STACKVAR] \
{ \
	if ((%var:offset > -0x1000) && (%var:offset < 0)) \
		@LOAD_IMM op1=opcode+0x10, rn=%var:base, i=-%var:offset; \
	else if ((%var:offset < 0x1000) && (%var:offset >= 0)) \
		@LOAD_IMM op1=opcode+0x18, rn=%var:base, i=%var:offset; \
	else if ((%var:offset > -0x10000) && (%var:offset < 0)) \
	{ \
		@MOV16 op1=0x10, rd=%var:temp, hi=(-%var:offset)>>12, lo=-%var:offset; \
		@LOAD_REG op1=opcode+0x10, rn=%var:base, rm=%var:temp; \
	} \
	else if ((%var:offset < 0x10000) && (%var:offset >= 0)) \
	{ \
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; \
		@LOAD_REG op1=opcode+0x18, rn=%var:base, rm=%var:temp; \
	} \
	else \
	{ \
		@MOV16 op1=0x10, rd=%var:temp, hi=%var:offset>>12, lo=%var:offset; \
		@MOV16 op1=0x14, rd=%var:temp, hi=%var:offset>>28, lo=%var:offset>>16; \
		@LOAD_REG op1=opcode+0x18, rn=%var:base, rm=%var:temp; \
	} \
}
LOAD_INSTR(str, r, 0)
LOAD_INSTR(ldr, w, 1)
LOAD_INSTR(strb, r, 4)
LOAD_INSTR(ldrb, w, 5)

instr(branch) bx  bx rm:REG(r)  { @MISC op=1, op1=0xf, op2=1, rd=0xf, rs=0xf; }

instr(call) blx  blx rm:REG(r), retval:REG(w), retvalhigh:REG(w), reads:REGLIST(r)
{
	@MISC op=1, op1=0xf, op2=3, rd=0xf, rs=0xf;
}

instr clz  clz rd:REG(w), rm:REG(r)  { @MISC op=3, op1=0xf, op2=1; }
instr bkpt  bkpt  { @MISC op=1, op2=7; }

instr rev  rev rd:REG(w), rm:REG(r)  { @REV op2=1; }
instr rev16  rev16 rd:REG(w), rm:REG(r)  { @REV op2=5; }

instr(memory) stmda  stmda rn:REG(r), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=0; }
instr(memory) stmda_update  stmda! rn:REG(rw), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=2; }
instr(memory) ldmda  ldmda rn:REG(r), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=1; }
instr(memory) ldmda_update  ldmda! rn:REG(rw), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=3; }
instr(memory) stmia  stmda rn:REG(r), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=8; }
instr(memory) stmia_update  stmda! rn:REG(rw), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=0xa; }
instr(memory) ldmia  ldmda rn:REG(r), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=9; }
instr(memory) ldmia_update  ldmda! rn:REG(rw), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=0xb; }
instr(memory) stmdb  stmda rn:REG(r), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=0x10; }
instr(memory) stmdb_update  stmda! rn:REG(rw), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=0x12; }
instr(memory) ldmdb  ldmda rn:REG(r), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=0x11; }
instr(memory) ldmdb_update  ldmda! rn:REG(rw), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=0x13; }
instr(memory) stmib  stmda rn:REG(r), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=0x18; }
instr(memory) stmib_update  stmda! rn:REG(rw), i:IMM, regs:REGLIST(r)  { @LOAD_MULTIPLE op=0x1a; }
instr(memory) ldmib  ldmda rn:REG(r), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=0x19; }
instr(memory) ldmib_update  ldmda! rn:REG(rw), i:IMM, regs:REGLIST(w)  { @LOAD_MULTIPLE op=0x1b; }

instr mcr  mrc coproc:IMM, opc1:IMM, rt:REG(w), crn:IMM, crm:IMM, opc2:IMM  { @COPROC dir=0; }
instr mrc  mrc coproc:IMM, opc1:IMM, rt:REG(w), crn:IMM, crm:IMM, opc2:IMM  { @COPROC dir=1; }

#define BRANCH_RELOC(dest) \
	Relocation reloc; \
	reloc.type = CODE_RELOC_RELATIVE_32_FIELD; \
	reloc.overflow = NULL; \
	reloc.instruction = out->len - 4; \
	reloc.offset = out->len - 4; \
	reloc.target = dest; \
	reloc.bitOffset = 0; \
	reloc.bitSize = 24; \
	reloc.bitShift = 2; \
	out->relocs.push_back(reloc);

instr(branch) b  b dest:FUNCTION  { @BRANCH op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) beq  beq dest:FUNCTION  { @BRANCH cond=COND_EQ, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bne  bne dest:FUNCTION  { @BRANCH cond=COND_NE, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bcs  bcs dest:FUNCTION  { @BRANCH cond=COND_CS, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bcc  bcc dest:FUNCTION  { @BRANCH cond=COND_CC, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bmi  bmi dest:FUNCTION  { @BRANCH cond=COND_MI, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bpl  bpl dest:FUNCTION  { @BRANCH cond=COND_PL, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bvs  bvs dest:FUNCTION  { @BRANCH cond=COND_VS, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bvc  bvc dest:FUNCTION  { @BRANCH cond=COND_VC, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bhi  bhi dest:FUNCTION  { @BRANCH cond=COND_HI, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bls  bls dest:FUNCTION  { @BRANCH cond=COND_LS, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bge  bge dest:FUNCTION  { @BRANCH cond=COND_GE, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) blt  blt dest:FUNCTION  { @BRANCH cond=COND_LT, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) bgt  bgt dest:FUNCTION  { @BRANCH cond=COND_GT, op=2, i=-1; BRANCH_RELOC(%dest:block); }
instr(branch) ble  ble dest:FUNCTION  { @BRANCH cond=COND_LE, op=2, i=-1; BRANCH_RELOC(%dest:block); }

instr(call) bl  bl dest:FUNCTION, retval:REG(w), retvalhigh:REG(w), reads:REGLIST(r)
{
	@BRANCH op=3, i=-1;
	BRANCH_RELOC(%dest:block);
}

instr(call) svc  svc num:REG(r), writes:REGLIST(w), reads:REGLIST(r)  { @SVC; }

instr saveregs  saveregs {} update
{
	vector<uint32_t> clobbered = func->GetClobberedCalleeSavedRegisters();
	clobbered.push_back(REG_FP);
	clobbered.push_back(REG_LR);
	uint32_t mask = 0;
	for (vector<uint32_t>::iterator i = clobbered.begin(); i != clobbered.end(); i++)
		mask |= 1 << *i;
	@stmdb_update SYMREG_SP, mask, clobbered;
	return true;
}

instr restoreregs  restoreregs {} update
{
	vector<uint32_t> clobbered = func->GetClobberedCalleeSavedRegisters();
	clobbered.push_back(REG_FP);
	clobbered.push_back(REG_PC);
	uint32_t mask = 0;
	for (vector<uint32_t>::iterator i = clobbered.begin(); i != clobbered.end(); i++)
		mask |= 1 << *i;
	@ldmia_update SYMREG_SP, mask, clobbered;
	return true;
}

// Data flow pseudo-instructions
instr regparam  regparam regs:REGLIST(w)  {} update { return true; }
instr symreturn  symreturn low:REG(r) high:REG(r)  {} update { return true; }

src:IMM8 => dest:IREG { @mov_imm %dest, %src; }
src:IMM8NOT => dest:IREG { @mvn_imm %dest, ~%src; }
src:IMM16 => dest:IREG { @movw %dest, %src; }
src:IMM => dest:IREG { @movw %dest, %src; @movt %dest, %src>>16; }
src:IMM8 => dest:IREG64 { @mov_imm %dest:low, %src; @mov_imm %dest:high, 0; }
src:IMM8NOT => dest:IREG64 { @mvn_imm %dest:low, ~%src; @mvn_imm %dest:high, 0; }
src:IMM16 => dest:IREG64 { @movw %dest:low, %src; @mov_imm %dest:high, 0; }
src:IMM => dest:IREG64
{
	@movw %dest:low, %src;
	@movt %dest:low, %src>>16;
	@movw %dest:high, %src>>32;
	@movt %dest:high, %src>>48;
}

src:IRESULT => dest:IREG(S8) { @sxtb %dest, %src, 0; }
src:IRESULT => dest:IREG(U8) { @uxtb %dest, %src, 0; }
src:IRESULT => dest:IREG(S16) { @sxth %dest, %src, 0; }
src:IRESULT => dest:IREG(U16) { @uxth %dest, %src, 0; }
src:IRESULT => dest:IREG(32) {}

func:FUNCTION => dest:IREG, temp:IREG { @add_block %dest, %func, %func->GetIL()[0], %temp; }

assign dest:IREG src:IREG { @mov %dest, %src; }
assign dest:IREG64 src:IREG64 { @mov %dest:low, %src:low; @mov %dest:high, %src:high; }

load(S8) base:IREG => dest:IREG { @ldrsb_imm %dest, %base, 0; }
load(S8) add base:IREG ofs:IMM8 => dest:IREG { @ldrsb_imm %dest, %base, %ofs; }
load(S8) add base:IREG ofs:IMM8NEG => dest:IREG { @ldrsb_sub_imm %dest, %base, -%ofs; }
load(S8) add base:IREG ofs:IREG => dest:IREG { @ldrsb_reg %dest, %base, %ofs; }
load(U8) base:IREG => dest:IREG { @ldrb_imm %dest, %base, 0; }
load(U8) add base:IREG ofs:IMM12 => dest:IREG { @ldrb_imm %dest, %base, %ofs; }
load(U8) add base:IREG ofs:IMM12NEG => dest:IREG { @ldrb_sub_imm %dest, %base, -%ofs; }
load(U8) add base:IREG ofs:IREG => dest:IREG { @ldrb_reg %dest, %base, %ofs; }
load(S16) base:IREG => dest:IREG { @ldrsh_imm %dest, %base, 0; }
load(S16) add base:IREG ofs:IMM8 => dest:IREG { @ldrsh_imm %dest, %base, %ofs; }
load(S16) add base:IREG ofs:IMM8NEG => dest:IREG { @ldrsh_sub_imm %dest, %base, -%ofs; }
load(S16) add base:IREG ofs:IREG => dest:IREG { @ldrsh_reg %dest, %base, %ofs; }
load(U16) base:IREG => dest:IREG { @ldrh_imm %dest, %base, 0; }
load(U16) add base:IREG ofs:IMM8 => dest:IREG { @ldrh_imm %dest, %base, %ofs; }
load(U16) add base:IREG ofs:IMM8NEG => dest:IREG { @ldrh_sub_imm %dest, %base, -%ofs; }
load(U16) add base:IREG ofs:IREG => dest:IREG { @ldrh_reg %dest, %base, %ofs; }
load(32) base:IREG => dest:IREG { @ldr_imm %dest, %base, 0; }
load(32) add base:IREG ofs:IMM12 => dest:IREG { @ldr_imm %dest, %base, %ofs; }
load(32) add base:IREG ofs:IMM12NEG => dest:IREG { @ldr_sub_imm %dest, %base, -%ofs; }
load(32) add base:IREG ofs:IREG => dest:IREG { @ldr_reg %dest, %base, %ofs; }
load(64) base:IREG => dest:IREG64
{
	@ldr_imm %dest:low, %base, m_settings.bigEndian ? 4 : 0;
	@ldr_imm %dest:high, %base, m_settings.bigEndian ? 0 : 4;
}
load(64) add base:IREG ofs:IMM12M4 => dest:IREG64
{
	@ldr_imm %dest:low, %base, %ofs + (m_settings.bigEndian ? 4 : 0);
	@ldr_imm %dest:high, %base, %ofs + (m_settings.bigEndian ? 0 : 4);
}
load(64) add base:IREG ofs:IMM12M4NEG => dest:IREG64
{
	@ldr_sub_imm %dest:low, %base, -(%ofs + (m_settings.bigEndian ? 4 : 0));
	@ldr_sub_imm %dest:high, %base, -(%ofs + (m_settings.bigEndian ? 0 : 4));
}
load(64) add base:IREG ofs:IREG => dest:IREG64, temp:IREG
{
	@add %temp, %base, %ofs;
	@ldr_imm %dest:low, %temp, m_settings.bigEndian ? 4 : 0;
	@ldr_imm %dest:high, %temp, m_settings.bigEndian ? 0 : 4;
}

load ref src:STACKVAR(S8) => dest:IREG { @ldrsb_stack %dest, %src; }
load ref src:STACKVAR(U8) => dest:IREG { @ldrb_stack %dest, %src; }
load ref src:STACKVAR(S16) => dest:IREG { @ldrsh_stack %dest, %src; }
load ref src:STACKVAR(U16) => dest:IREG { @ldrh_stack %dest, %src; }
load ref src:STACKVAR(32) => dest:IREG { @ldr_stack %dest, %src; }
load ref src:STACKVAR(64) => dest:IREG64
{
	if (m_settings.bigEndian)
	{
		@ldr_stack %dest:low, %src:4;
		@ldr_stack %dest:high, %src:0;
	}
	else
	{
		@ldr_stack %dest:low, %src:0;
		@ldr_stack %dest:high, %src:4;
	}
}

store(8) base:IREG src:IREG { @strb_imm %src, %base, 0; }
store(8) add base:IREG ofs:IMM12 src:IREG { @strb_imm %src, %base, %ofs; }
store(8) add base:IREG ofs:IMM12NEG src:IREG { @strb_sub_imm %src, %base, -%ofs; }
store(8) add base:IREG ofs:IREG src:IREG { @strb_reg %src, %base, %ofs; }
store(16) base:IREG src:IREG { @strh_imm %src, %base, 0; }
store(16) add base:IREG ofs:IMM8 src:IREG { @strh_imm %src, %base, %ofs; }
store(16) add base:IREG ofs:IMM8NEG src:IREG { @strh_sub_imm %src, %base, -%ofs; }
store(16) add base:IREG ofs:IREG src:IREG { @strh_reg %src, %base, %ofs; }
store(32) base:IREG src:IREG { @str_imm %src, %base, 0; }
store(32) add base:IREG ofs:IMM12 src:IREG { @str_imm %src, %base, %ofs; }
store(32) add base:IREG ofs:IMM12NEG src:IREG { @str_sub_imm %src, %base, -%ofs; }
store(32) add base:IREG ofs:IREG src:IREG { @str_reg %src, %base, %ofs; }
store(64) base:IREG src:IREG64
{
	@str_imm %src:low, %base, m_settings.bigEndian ? 4 : 0;
	@str_imm %src:high, %base, m_settings.bigEndian ? 0 : 4;
}
store(64) add base:IREG ofs:IMM12M4 src:IREG64
{
	@str_imm %src:low, %base, %ofs + (m_settings.bigEndian ? 4 : 0);
	@str_imm %src:high, %base, %ofs + (m_settings.bigEndian ? 0 : 4);
}
store(64) add base:IREG ofs:IMM12M4NEG src:IREG64
{
	@str_sub_imm %src:low, %base, -(%ofs + (m_settings.bigEndian ? 4 : 0));
	@str_sub_imm %src:high, %base, -(%ofs + (m_settings.bigEndian ? 0 : 4));
}
store(64) add base:IREG ofs:IREG src:IREG64, temp:IREG
{
	@add %temp, %base, %ofs;
	@str_imm %src:low, %base, m_settings.bigEndian ? 4 : 0;
	@str_imm %src:high, %base, m_settings.bigEndian ? 0 : 4;
}

store ref dest:STACKVAR(8) src:IREG { @strb_stack %src, %dest; }
store ref dest:STACKVAR(16) src:IREG { @strh_stack %src, %dest; }
store ref dest:STACKVAR(32) src:IREG { @str_stack %src, %dest; }
store ref dest:STACKVAR(64) src:IREG64
{
	if (m_settings.bigEndian)
	{
		@str_stack %src:low, %dest:4;
		@str_stack %src:high, %dest:0;
	}
	else
	{
		@str_stack %src:low, %dest:0;
		@str_stack %src:high, %dest:4;
	}
}

ref base:GLOBALVAR => dest:IREG { @add_global %dest, %base; }
ref base:STACKVAR => dest:IREG { @add_stack %dest, %base; }

add a:IREG b:IREG => dest:IRESULT { @add %dest, %a, %b; }
add a:IREG b:IMM8 => dest:IRESULT { @add_imm %dest, %a, %b; }
add a:IREG b:IMM8NEG => dest:IRESULT { @sub_imm %dest, %a, %b; }
add a:IREG shl b:IREG c:IMM => dest:IRESULT { @add_lsl_imm %dest, %a, %b, %c; }
add a:IREG shr b:IREG c:IMM => dest:IRESULT { @add_lsr_imm %dest, %a, %b, %c; }
add a:IREG sar b:IREG c:IMM => dest:IRESULT { @add_asr_imm %dest, %a, %b, %c; }
add a:IREG shl b:IREG c:IREG => dest:IRESULT { @add_lsl_reg %dest, %a, %b, %c; }
add a:IREG shr b:IREG c:IREG => dest:IRESULT { @add_lsr_reg %dest, %a, %b, %c; }
add a:IREG sar b:IREG c:IREG => dest:IRESULT { @add_asr_reg %dest, %a, %b, %c; }
add a:IREG64 b:IREG64 => dest:IREG64 { @adds %dest:low, %a:low, %b:low; @adc %dest:high, %a:high, %b:high; }

sub a:IREG b:IREG => dest:IRESULT { @sub %dest, %a, %b; }
sub a:IREG b:IMM8 => dest:IRESULT { @sub_imm %dest, %a, %b; }
sub a:IREG b:IMM8NEG => dest:IRESULT { @add_imm %dest, %a, %b; }
sub a:IREG shl b:IREG c:IMM => dest:IRESULT { @sub_lsl_imm %dest, %a, %b, %c; }
sub a:IREG shr b:IREG c:IMM => dest:IRESULT { @sub_lsr_imm %dest, %a, %b, %c; }
sub a:IREG sar b:IREG c:IMM => dest:IRESULT { @sub_asr_imm %dest, %a, %b, %c; }
sub a:IREG shl b:IREG c:IREG => dest:IRESULT { @sub_lsl_reg %dest, %a, %b, %c; }
sub a:IREG shr b:IREG c:IREG => dest:IRESULT { @sub_lsr_reg %dest, %a, %b, %c; }
sub a:IREG sar b:IREG c:IREG => dest:IRESULT { @sub_asr_reg %dest, %a, %b, %c; }
sub a:IREG64 b:IREG64 => dest:IREG64 { @subs %dest:low, %a:low, %b:low; @sbc %dest:high, %a:high, %b:high; }

#define MUL_INSTR(op) \
op a:IREG b:IREG => dest:IRESULT { @mul %dest, %a, %b; } \
op a:IREG64 b:IREG64 => dest:IREG64, temp:IREG \
{ \
	@umull %dest:low, %dest:high, %a:low, %b:low; \
	@mul %temp, %a:low, %b:high; \
	@add %dest:high, %dest:high, %temp; \
	@mul %temp, %a:high, %b:low; \
	@add %dest:high, %dest:high, %temp; \
}
MUL_INSTR(smul)
MUL_INSTR(umul)

#define BITWISE_OP(op, instr) \
op a:IREG b:IREG => dest:IREG { instr %dest, %a, %b; } \
op a:IREG b:IMM8 => dest:IREG { instr##_imm %dest, %a, %b; } \
op a:IREG shl b:IREG c:IMM => dest:IREG { instr##_lsl_imm %dest, %a, %b, %c; } \
op a:IREG shr b:IREG c:IMM => dest:IREG { instr##_lsr_imm %dest, %a, %b, %c; } \
op a:IREG sar b:IREG c:IMM => dest:IREG { instr##_asr_imm %dest, %a, %b, %c; } \
op a:IREG shl b:IREG c:IREG => dest:IREG { instr##_lsl_reg %dest, %a, %b, %c; } \
op a:IREG shr b:IREG c:IREG => dest:IREG { instr##_lsr_reg %dest, %a, %b, %c; } \
op a:IREG sar b:IREG c:IREG => dest:IREG { instr##_asr_reg %dest, %a, %b, %c; }
BITWISE_OP(and, @and)
BITWISE_OP(or, @orr)
BITWISE_OP(xor, @eor)

shl a:IREG b:IMM => dest:IRESULT { @lsl_imm %dest, %a, %b; }
shl a:IREG b:IREG => dest:IRESULT { @lsl %dest, %a, %b; }
shr a:IREG b:IMM => dest:IRESULT { @lsr_imm %dest, %a, %b; }
shr a:IREG b:IREG => dest:IRESULT { @lsr %dest, %a, %b; }
sar a:IREG b:IMM => dest:IRESULT { @asr_imm %dest, %a, %b; }
sar a:IREG b:IREG => dest:IRESULT { @asr %dest, %a, %b; }

neg a:IREG => dest:IRESULT { @rsb_imm %dest, %a, 0; }
neg a:IREG64 => dest:IREG64 { @rsbs_imm %dest:low, %a:low, 0; @rsc_imm %dest:high, %a:high, 0; }
not a:IREG => dest:IRESULT { @mvn %dest, %a; }
not a:IREG64 => dest:IREG64 { @mvn %dest:low, %a:low; @mvn %dest:high, %a:high; }

sconvert src:IREG(8) => dest:IREG(16,32) { @sxtb %dest, %src, 0; }
sconvert src:IREG(8) => dest:IREG64 { @sxtb %dest:low, %src, 0; @asr_imm %dest:high, %dest:low, 31; }
uconvert src:IREG(8) => dest:IREG(16,32) { @uxtb %dest, %src, 0; }
uconvert src:IREG(8) => dest:IREG64 { @uxtb %dest:low, %src, 0; @mov_imm %dest:high, 0; }
sconvert src:IREG(16) => dest:IREG(32) { @sxth %dest, %src, 0; }
sconvert src:IREG(16) => dest:IREG64 { @sxth %dest:low, %src, 0; @asr_imm %dest:high, %dest:low, 31; }
uconvert src:IREG(16) => dest:IREG(32) { @uxth %dest, %src, 0; }
uconvert src:IREG(16) => dest:IREG64 { @uxth %dest:low, %src, 0; @mov_imm %dest:high, 0; }
sconvert src:IREG(32) => dest:IREG64 { @mov %dest:low, %src; @asr_imm %dest:high, %dest:low, 31; }
uconvert src:IREG(32) => dest:IREG64 { @mov %dest:low, %src; @mov_imm %dest:high, 0; }
sconvert src:IREG(16,32) => dest:IREG(8) { @sxtb %dest, %src, 0; }
sconvert src:IREG64 => dest:IREG(8) { @sxtb %dest, %src:low, 0; }
uconvert src:IREG(16,32) => dest:IREG(8) { @uxtb %dest, %src, 0; }
uconvert src:IREG64 => dest:IREG(8) { @uxtb %dest, %src:low, 0; }
sconvert src:IREG(32) => dest:IREG(16) { @sxth %dest, %src, 0; }
sconvert src:IREG64 => dest:IREG(16) { @sxth %dest, %src:low, 0; }
uconvert src:IREG(32) => dest:IREG(16) { @uxth %dest, %src, 0; }
uconvert src:IREG64 => dest:IREG(16) { @uxth %dest, %src:low, 0; }
sconvert src:IREG64 => dest:IREG(32) { @mov %dest, %src:low; }
uconvert src:IREG64 => dest:IREG(32) { @mov %dest, %src:low; }

byteswap src:IREG(16) => dest:IREG { @rev16 %dest, %src; }
byteswap src:IREG(32) => dest:IREG { @rev %dest, %src; }
byteswap src:IREG64 => dest:IREG64 { @rev %dest:high, %src:low; @rev %dest:low, %src:high; }

function void UnconditionalJump(SymInstrBlock* out, TreeBlock* block)
{
	if ((!m_settings.pad) && (block->GetSource()->GetGlobalIndex() == (m_currentBlock->GetSource()->GetGlobalIndex() + 1)))
	{
		// The destination block is the one just after the current one, just fall through
		return;
	}
	@b m_func, block->GetSource();
}

iftrue src:IREG t:BLOCK f:BLOCK { @cmp_imm %src, 0; @bne m_func, %t->GetSource(); UnconditionalJump(out, %f); }
iftrue src:IREG64 t:BLOCK f:BLOCK
{
	@cmp_imm %src:low, 0;
	@bne m_func, %t->GetSource();
	@cmp_imm %src:high, 0;
	@bne m_func, %t->GetSource();
	UnconditionalJump(out, %f);
}

ife a:IREG b:IREG t:BLOCK f:BLOCK { @cmp %a, %b; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG b:IMM8 t:BLOCK f:BLOCK { @cmp_imm %a, %b; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG b:IMM8NEG t:BLOCK f:BLOCK { @cmn_imm %a, -%b; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG shl b:IREG c:IMM t:BLOCK f:BLOCK { @cmp_lsl_imm %a, %b, %c; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG shr b:IREG c:IMM t:BLOCK f:BLOCK { @cmp_lsr_imm %a, %b, %c; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG sar b:IREG c:IMM t:BLOCK f:BLOCK { @cmp_asr_imm %a, %b, %c; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG shl b:IREG c:IREG t:BLOCK f:BLOCK { @cmp_lsl_reg %a, %b, %c; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG shr b:IREG c:IREG t:BLOCK f:BLOCK { @cmp_lsr_reg %a, %b, %c; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG sar b:IREG c:IREG t:BLOCK f:BLOCK { @cmp_asr_reg %a, %b, %c; @beq m_func, %t->GetSource(); UnconditionalJump(out, %f); }
ife a:IREG64 b:IREG64 t:BLOCK f:BLOCK
{
	@cmp %a:low, %b:low;
	@bne m_func, %f->GetSource();
	@cmp %a:high, %b:high;
	@beq m_func, %t->GetSource();
	UnconditionalJump(out, %f);
}

#define COND_COMPARE(op, instr, lowInstr, highInstr) \
op a:IREG b:IREG t:BLOCK f:BLOCK { @cmp %a, %b; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG b:IMM8 t:BLOCK f:BLOCK { @cmp_imm %a, %b; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG b:IMM8NEG t:BLOCK f:BLOCK { @cmn_imm %a, -%b; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG shl b:IREG c:IMM t:BLOCK f:BLOCK { @cmp_lsl_imm %a, %b, %c; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG shr b:IREG c:IMM t:BLOCK f:BLOCK { @cmp_lsr_imm %a, %b, %c; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG sar b:IREG c:IMM t:BLOCK f:BLOCK { @cmp_asr_imm %a, %b, %c; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG shl b:IREG c:IREG t:BLOCK f:BLOCK { @cmp_lsl_reg %a, %b, %c; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG shr b:IREG c:IREG t:BLOCK f:BLOCK { @cmp_lsr_reg %a, %b, %c; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG sar b:IREG c:IREG t:BLOCK f:BLOCK { @cmp_asr_reg %a, %b, %c; instr m_func, %t->GetSource(); UnconditionalJump(out, %f); } \
op a:IREG64 b:IREG64 t:BLOCK f:BLOCK \
{ \
	@cmp %a:high, %b:high; \
	highInstr m_func, %t->GetSource(); \
	@bne m_func, %f->GetSource(); \
	@cmp %a:low, %b:low; \
	lowInstr m_func, %t->GetSource(); \
	UnconditionalJump(out, %f); \
}
COND_COMPARE(ifslt, @blt, @bcc, @blt)
COND_COMPARE(ifult, @bcc, @bcc, @bcc)
COND_COMPARE(ifsle, @ble, @bls, @blt)
COND_COMPARE(ifule, @bls, @bls, @bcc)

goto dest:BLOCK { UnconditionalJump(out, %dest); }
goto dest:IREG { @bx %dest; }

breakpoint { @bkpt; }

function void AdjustStackAfterCall(SymInstrBlock* out, uint32_t stackAdjust)
{
	if (stackAdjust != 0)
	{
		if (m_settings.stackGrowsUp)
			@sub_imm SYMREG_SP, SYMREG_SP, stackAdjust;
		else
			@add_imm SYMREG_SP, SYMREG_SP, stackAdjust;
	}
}

call func:FUNCTION reads:INPUT stackAdjust:IMM16 => dest:INTEGER_RETURN_VALUE
{
	@bl %func, %func->GetIL()[0], %dest, SYMREG_NONE, %reads;
	AdjustStackAfterCall(out, (uint32_t)%stackAdjust);
}

call func:FUNCTION reads:INPUT stackAdjust:IMM16 => dest:INTEGER_RETURN_VALUE_64
{
	@bl %func, %func->GetIL()[0], %dest:low, %dest:high, %reads;
	AdjustStackAfterCall(out, (uint32_t)%stackAdjust);
}

callvoid func:FUNCTION reads:INPUT stackAdjust:IMM16
{
	@bl %func, %func->GetIL()[0], SYMREG_NONE, SYMREG_NONE, %reads;
	AdjustStackAfterCall(out, (uint32_t)%stackAdjust);
}

call func:IREG reads:INPUT stackAdjust:IMM16 => dest:INTEGER_RETURN_VALUE
{
	@blx %func, %dest, SYMREG_NONE, %reads;
	AdjustStackAfterCall(out, (uint32_t)%stackAdjust);
}

call func:IREG reads:INPUT stackAdjust:IMM16 => dest:INTEGER_RETURN_VALUE_64
{
	@blx %func, %dest:low, %dest:high, %reads;
	AdjustStackAfterCall(out, (uint32_t)%stackAdjust);
}

callvoid func:IREG reads:INPUT stackAdjust:IMM16
{
	@blx %func, SYMREG_NONE, SYMREG_NONE, %reads;
	AdjustStackAfterCall(out, (uint32_t)%stackAdjust);
}

function bool GenerateReturnVoid(SymInstrBlock* out)
{
	// Restore frame pointer (if present) and adjust stack
	if (m_framePointerEnabled)
	{
		@mov SYMREG_SP, SYMREG_BP;
	}
	else
	{
		// TODO: Support frames without a frame pointer
		return false;
	}

	// The restore register function also pops PC off the stack
	@restoreregs;
	return true;
}

return src:IREG, retval:INTEGER_RETURN_VALUE { @mov %retval, %src; GenerateReturnVoid(out); @symreturn %retval, SYMREG_NONE; }
return src:IREG64, retval:INTEGER_RETURN_VALUE_64
{
	@mov %retval:low, %src:low;
	@mov %retval:high, %src:high;
	GenerateReturnVoid(out);
	@symreturn %retval:low, %retval:high;
}
returnvoid { GenerateReturnVoid(out); }

alloca size:IREG => result:IREG, temp:IREG
{
	if (m_settings.stackGrowsUp)
	{
		@add_imm SYMREG_SP, SYMREG_SP, 4;
		@mov %result, SYMREG_SP;
		@add SYMREG_SP, SYMREG_SP, %size;
		@mvn_imm %temp, 3;
		@and SYMREG_SP, SYMREG_SP, %temp;
	}
	else
	{
		@sub SYMREG_SP, SYMREG_SP, %size;
		@mvn_imm %temp, 3;
		@and SYMREG_SP, SYMREG_SP, %temp;
		@mov %result, SYMREG_SP;
	}
}

alloca size:IMM8 => result:IREG, temp:IREG
{
	if (m_settings.stackGrowsUp)
	{
		@add_imm SYMREG_SP, SYMREG_SP, 4;
		@mov %result, SYMREG_SP;
		@add_imm SYMREG_SP, SYMREG_SP, %size;
		@mvn_imm %temp, 3;
		@and SYMREG_SP, SYMREG_SP, %temp;
	}
	else
	{
		@sub_imm SYMREG_SP, SYMREG_SP, %size;
		@mvn_imm %temp, 3;
		@and SYMREG_SP, SYMREG_SP, %temp;
		@mov %result, SYMREG_SP;
	}
}

vararg => result:IREG, temp:IREG { @add_stack %result, SYMREG_BP, m_varargStart, 0, %temp; }

push src:IREG { @str_sub_imm_pre %src, SYMREG_SP, 4; }
push src:IREG64
{
	if (m_settings.bigEndian)
	{
		@str_sub_imm %src:low, SYMREG_SP, 4;
		@str_sub_imm_pre %src:high, SYMREG_SP, 8;
	}
	else
	{
		@str_sub_imm %src:high, SYMREG_SP, 4;
		@str_sub_imm_pre %src:low, SYMREG_SP, 8;
	}
}

syscall num:IMM16 reads:INPUT stackAdjust:IMM => dest:SYSCALL_RETURN, numreg:SYSCALL_NUM
{
	vector<uint32_t> writes;
	writes.push_back(%dest);
	@movw %numreg, %num;
	@svc %numreg, writes, %reads;
}

syscall num:IREG reads:INPUT stackAdjust:IMM => dest:SYSCALL_RETURN, numreg:SYSCALL_NUM
{
	vector<uint32_t> writes;
	writes.push_back(%dest);
	@mov %numreg, %num;
	@svc %numreg, writes, %reads;
}

syscall num:IMM16 reads:INPUT stackAdjust:IMM => dest:SYSCALL_RETURN_64, numreg:SYSCALL_NUM
{
	vector<uint32_t> writes;
	writes.push_back(%dest:low);
	writes.push_back(%dest:high);
	@movw %numreg, %num;
	@svc %numreg, writes, %reads;
}

syscall num:IREG reads:INPUT stackAdjust:IMM => dest:SYSCALL_RETURN_64, numreg:SYSCALL_NUM
{
	vector<uint32_t> writes;
	writes.push_back(%dest:low);
	writes.push_back(%dest:high);
	@mov %numreg, %num;
	@svc %numreg, writes, %reads;
}

peb => dest:IREG  { @mrc 15, 0, %dest, 13, 0, 2; }

function void GenerateAntiDisassembly(SymInstrBlock* out)
{
}

function bool GenerateFunctionStart(SymInstrBlock* out)
{
	if ((m_func->GetName() == "_start") && m_settings.unsafeStack)
	{
		// This is the start function, and we can't assume we have a safe stack (the code may be
		// at or near the stack pointer), pivot the stack to make it safe
		uint32_t reg = TEMP_REGISTER(IREG);
		@movw reg, UNSAFE_STACK_PIVOT;
		@sub SYMREG_SP, SYMREG_SP, reg;
	}

	// Generate function prologue
	if (m_framePointerEnabled)
	{
		@saveregs;
		@mov SYMREG_BP, SYMREG_SP;
	}
	else
	{
		@saveregs;
	}

	// Generate a pseudo instruction to ensure the incoming parameters are defined
	vector<uint32_t> incomingRegs;
	for (vector<IncomingParameterCopy>::iterator j = m_paramCopy.begin(); j != m_paramCopy.end(); j++)
	{
		if (j->stackVar != SYMREG_NONE)
			continue;

		incomingRegs.push_back(j->incomingReg);
		if (j->var->GetType()->GetWidth() == 8)
			incomingRegs.push_back(j->incomingReg + 1);
	}

	if (incomingRegs.size() != 0)
		@regparam incomingRegs;

	// Copy parameters into variables so that they can be spilled if needed
	for (vector<IncomingParameterCopy>::iterator j = m_paramCopy.begin(); j != m_paramCopy.end(); j++)
	{
		if (j->stackVar != SYMREG_NONE)
		{
			// Parameter was spilled onto stack
			switch (j->var->GetType()->GetWidth())
			{
			case 1:
				@strb_stack j->incomingReg, SYMREG_BP, j->stackVar, 0, TEMP_REGISTER(IREG);
				break;
			case 2:
				@strh_stack j->incomingReg, SYMREG_BP, j->stackVar, 0, TEMP_REGISTER(IREG);
				break;
			case 4:
				@str_stack j->incomingReg, SYMREG_BP, j->stackVar, 0, TEMP_REGISTER(IREG);
				break;
			case 8:
				if (m_settings.bigEndian)
				{
					@str_stack j->incomingHighReg, SYMREG_BP, j->stackVar, 0, TEMP_REGISTER(IREG);
					@str_stack j->incomingReg, SYMREG_BP, j->stackVar, 4, TEMP_REGISTER(IREG);
				}
				else
				{
					@str_stack j->incomingReg, SYMREG_BP, j->stackVar, 0, TEMP_REGISTER(IREG);
					@str_stack j->incomingHighReg, SYMREG_BP, j->stackVar, 4, TEMP_REGISTER(IREG);
				}
				break;
			default:
				fprintf(stderr, "error: spilling invalid parameter\n");
				return false;
			}
		}
		else
		{
			// Parameter is in an integer register
			uint32_t newReg = TEMP_REGISTER(IREG);
			uint32_t newHighReg = SYMREG_NONE;
			if (j->var->GetType()->GetWidth() == 8)
				newHighReg = TEMP_REGISTER(IREG);

			@mov newReg, j->incomingReg;
			if (newHighReg != SYMREG_NONE)
				@mov newHighReg, j->incomingHighReg;
			m_vars.registerVariables[j->var] = newReg;
			if (newHighReg != SYMREG_NONE)
				m_vars.highRegisterVariables[j->var] = newHighReg;
		}
	}

	if (m_framePointerEnabled)
	{
		uint32_t temp = TEMP_REGISTER(IREG);
		if (m_settings.stackGrowsUp)
			@add_stack SYMREG_SP, SYMREG_SP, SYMVAR_FRAME_SIZE, 0, temp;
		else
			@sub_stack SYMREG_SP, SYMREG_SP, SYMVAR_FRAME_SIZE, 0, temp;
	}

	return true;
}

arch function set<uint32_t> GetRegisterClassInterferences(uint32_t cls)
{
	set<uint32_t> result;
	return result;
}

arch function bool DoesRegisterClassConflictWithSpecialRegisters(uint32_t cls)
{
	return false;
}

arch function void LayoutStackFrame()
{
	// Lay out stack variables
	int64_t offset = 0;
	for (size_t i = 0; i < m_stackVarOffsets.size(); i++)
	{
		if (m_stackVarIsParam[i])
			continue;

		int64_t align = 1;
		if (m_stackVarWidths[i] >= 4)
			align = 4;
		else if (m_stackVarWidths[i] >= 2)
			align = 2;

		if ((offset & (align - 1)) != 0)
			offset += align - (offset & (align - 1));

		m_stackVarOffsets[i] = offset;
		offset += m_stackVarWidths[i];
	}

	// Ensure stack stays aligned on native boundary
	if (offset & 3)
		offset += 4 - (offset & 3);

	m_stackFrameSize = offset;

	// Adjust variable offsets to be relative to the frame pointer (negative offsets)
	if (m_settings.stackGrowsUp)
	{
		for (size_t i = 0; i < m_stackVarOffsets.size(); i++)
		{
			if (!m_stackVarIsParam[i])
				m_stackVarOffsets[i] -= offset;
		}
	}

	for (size_t i = 0; i < m_stackVarOffsets.size(); i++)
	{
		if (m_stackVarIsParam[i])
			continue;
		if (m_settings.stackGrowsUp)
			m_stackVarOffsets[i] += m_stackFrameSize;
		else
			m_stackVarOffsets[i] -= m_stackFrameSize;
	}

	// Account for callee saved registers
	int32_t adjust = 8 + (m_clobberedCalleeSavedRegs.size() * 4);
	for (size_t i = 0; i < m_stackVarOffsets.size(); i++)
	{
		if (!m_stackVarIsParam[i])
			continue;

		if (m_settings.stackGrowsUp)
			m_stackVarOffsets[i] -= adjust;
		else
			m_stackVarOffsets[i] += adjust;
	}
}

arch function bool GenerateSpillLoad(uint32_t reg, uint32_t var, int64_t offset,
	ILParameterType type, vector<SymInstr*>& code)
{
	uint32_t temp = AddRegister(IREG);
	switch (type)
	{
	case ILTYPE_INT8:
		@ldrb_stack reg, SYMREG_BP, var, offset, temp;
		break;
	case ILTYPE_INT16:
		@ldrh_stack reg, SYMREG_BP, var, offset, temp;
		break;
	case ILTYPE_INT32:
	case ILTYPE_INT64: // Uses two 32-bit regs
		@ldr_stack reg, SYMREG_BP, var, offset, temp;
		break;
	default:
		return false;
	}

	return true;
}

arch function bool GenerateSpillStore(uint32_t reg, uint32_t var, int64_t offset,
	ILParameterType type, vector<SymInstr*>& code)
{
	uint32_t temp = AddRegister(IREG);
	switch (type)
	{
	case ILTYPE_INT8:
		@strb_stack reg, SYMREG_BP, var, offset, temp;
		break;
	case ILTYPE_INT16:
		@strh_stack reg, SYMREG_BP, var, offset, temp;
		break;
	case ILTYPE_INT32:
	case ILTYPE_INT64: // Uses two 32-bit regs
		@str_stack reg, SYMREG_BP, var, offset, temp;
		break;
	default:
		return false;
	}

	return true;
}

arch function void PrintRegister(uint32_t reg)
{
	if (reg == SYMREG_NATIVE_REG(REG_FP))
		fprintf(stderr, "fp");
	else if (reg == SYMREG_NATIVE_REG(REG_LR))
		fprintf(stderr, "lr");
	else if (reg == SYMREG_NATIVE_REG(REG_SP))
		fprintf(stderr, "sp");
	else if (reg == SYMREG_NATIVE_REG(REG_PC))
		fprintf(stderr, "pc");
	else if ((reg >= SYMREG_NATIVE_REG(0)) && (reg <= SYMREG_NATIVE_REG(15)))
		fprintf(stderr, "r%d", reg - SYMREG_NATIVE_REG(0));
	else
		SymInstrFunction::PrintRegister(reg);
}

